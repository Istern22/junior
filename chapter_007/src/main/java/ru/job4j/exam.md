Чем отличается процесс от потока?
==========
Процесс - это выполняющаяся программа, состоит хотя бы из одного потока,
использует отдельное адресное пространство.
Поток - это часть программы, которая задает отдельный путь исполнения процесса.
Потоки используют одно адресное пространств процесса, взаимодействуют.

Каким образом можно создать поток?
=======================
Создать поток можно с помощью интерфейса Runnable, нужно переопределить 
метод run(), и передать его в новый поток.

    Runnable task = () -> {
		System.out.println("Hello, World!");
	};
	Thread thread = new Thread(task);
	thread.start();
	
Или можно создать потомка класса Thread и переопределить его метод run();

    public static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello, World!");
        }
    }

Как работают методы sleep, yield, wait, notify и notifyAll?
==========

Sleep
----
Статический метод.
Приостанавливает выполнение потока, в котором он был вызван, т.е. переключается
из RUNNABLE в TIMED_WAITING.

Yield
-----
Статический метод.
Заставляет процессор переключиться на обработку других потоков системы

Wait
-----
Нестатический метод.
Освобождает монитор и переводит вызывающий поток в состояние ожидания 
до тех пор, пока другой поток не вызовет метод notify().

Notify
----
Нестатический метод.
Продолжает работу потока, у которого ранее был вызван метод wait(

NotifyAll
----
Нестатический метод.
Возобновляет работу всех потоков, у которых ранее был вызван метод wait()


Объясните следующие термины: монитор, мьютекс, критическая секция.
======
Монитор
------
Монитор - это механизм для управления одновременным доступом к объекту.
Монитор — это дополнительная «надстройка» над мьютексом. С каждым объектом 
ассоциирован некоторый монитор, а потоки могут его занять или освободить.

Мьютекс
-------
1) Мьютекс - это объект, позволяющий "захватывать" себя одному и только одному потоку.
2) Если один поток "захватил" мьютекс, остальные потоки должны ждать, когда мьютекс освободиться.
3) Освободить мьютекс может только захвативший его поток.

Критическая секция
-----------
Это участок кода, в котором производится доступ к общему ресурсу, который 
не должен быть одновременно использован более чем одним потоком.

Как работает join()?
=======
Нестатический метод.
Это механизм, позволяющий одному потоку ждать завершения выполнения другого.
Например, чтобы главный поток подождал завершения побочного потока, 
необходимо выполнить join() в главном потоке.

Что такое DeadLock? Приведите примеры.
========
Deadlock или дедлок или взаимная блокировка — это ошибка, которая возникает, 
когда один поток держит мютекс, нужный второму потоку, 
а второй поток держит мютекс, нужный первому потоку.

Необходимо произвести две транзакции: со счета A на счет B перевести x денег, 
а со счета B на счет A – y. При неудачном стечении обстоятельств, транзакция 1 
займет монитор счета A, транзакция 2 займет монитор счета B. Результат – взаимная 
блокировка: транзакция 1 ждет, пока транзакция 2 освободит монитор счета B, но для 
этого транзакция 2 должна получить доступ к монитору A, занятому транзакцией 1.

Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
=========================
1. SynchronizedMap - при использовании потоком блокируется вся карта.
ConcurrentHashMap - блокируется только один bucket(ведро).
2. SynchronizedMap - использовать объект в момент времени может только один поток.
ConcurrentHashMap - читать могут все потоки, писать - один поток на bucket.
3. SynchronizedMap - кидает CocurrentModificationException если карта была изменена во время итерирования.
ConcurrentHashMap - не кидает CocurrentModificationException если карту изменили во время итерирования.
Но и ничего не гарантирует.

Различия в интерфейсах Runnable и Callable.
==================
1. Runnable - метод run(), ничего не возвращает.
Callable - метод call(), возвращает значение.
2. Runnable - запуск через Thread(Runnable).start(), ExecutorService, FutureTask.
Callable - запуск через ExecutorService, FutureTask.
3. Runnable - не бросает исключения, Callable - бросает проверяемые Exception. 

Callable - Возвращаемое значение и брошенные исключения из Callable записываются в объект класса Future.
Метод future.get() выдает возвращенное значение, если операция прошла успешно.

Различия между isInterrupted(), interrupted().
============================
1. thread.isInterrupted() - Нестатический метод. Возвращает информацию о любом потоке, 
на объекте которого вызван. 
boolean thread.isInterrupted(), boolean Thread.currentThread.isInterrupted()
Thread.interrupted() - Статический метод. Возвращает информацию только о потоке, в котором вызван.
 


Что происходит при вызове Thread.interrupt()?
===============

11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.

Назовите отличия synchronize{} и ReentrantLock.
=================
В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного
и тонкого контроля блокировки ресурсов. ReentrantLock – распространённая 
реализация Lock, которая предоставляет Lock с таким же базовым поведением и 
семантикой, как у synchronized, но расширенными возможностями, такими как 
опрос о блокировании (lock polling), ожидание блокирования заданной 
длительности и прерываемое ожидание блокировки. Кроме того, он предлагает 
гораздо более высокую эффективность функционирования в условиях жесткой 
состязательности.

Приведите наиболее существенное отличие между CountDownLatch и Barrier.
===================
CyclicBarrier похож на CountDownLatch, но главное различие между ними в том, 
что использовать «замок» можно лишь единожды - после того, как его счётчик 
достигнет нуля, а «барьер» можно использовать неоднократно, даже после того, 
как он «сломается».


Отличие Thread.start() и Thread.run()
==============
Разница заключается в том, что Thread.start() запускает поток, который 
вызывает метод run() , в то время как Runnable.run() просто вызывает 
метод run() в текущем потоке.

Объясните ключевое слово volatile.
============= 
Если мы объявляем переменную с ключевым словом volatile, это значит, что она
всегда будет атомарно читаться и записываться и JVM не будет помещать ее в кэш.

Расскажите про приоритеты потока.
===================
Приоритеты потоков используются планировщиком потоков для принятия решений 
о том, когда какому из потоков будет разрешено работать. 
Теоретически высокоприоритетные потоки получают больше времени процессора, 
чем низкоприоритетные. Практически объем времени процессора, который получает 
поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса Thread: 
final void setPriority(int level). Значение level изменяется в пределах 
от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - 
Thread.NORM_PRlORITY = 5.

Получить текущее значение приоритета потока можно вызвав метод: 
final int getPriority() у экземпляра класса Thread.

Что такое потоки-демоны?
=========
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются 
неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне 
работы основных потоков выполнения и его деятельность заключается в обслуживании 
основных потоков приложения, то такой процесс может быть запущен как поток-демон 
с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. 
Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном 
или нет. Базовое свойство потоков-демонов заключается в возможности основного 
потока приложения завершить выполнение потока-демона (в отличие от обычных потоков)
с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще 
работает.

Назовите все возможные состояния потока.
=========
Поток может выполняться. Он может быть готовым к выполнению, как только
получит время ЦП. Работающий поток может быть приостановлен, что приводит
к временному прекращению его активности. Выполнение приостановленного потока
может быть возобновлено, что позволяет продолжить его выполнение с того
места, где он был приостановлен. Поток может быть заблокирован на время ожидания
какого-нибудь ресурса. В любой момент поток может быть прерван, что
приводит к немедленной остановке его исполнения. Однажды прерванный поток
исполнения уже не может быть возобновлен.

Что такое race condition?
===========
Состояние гонки (race condition) - ошибка проектирования многопоточной системы или
приложения, при которой эта работа напрямую зависит от того, в каком порядке 
выполняются потоки. Состояние гонки возникает когда поток, который должен 
исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение 
кода изменяется, из-за чего возникают недетерменированные ошибки.

Что такое Thread Local переменная?
=================
Класс ThreadLocal представляет хранилище тред-локальных переменных. По способу 
использования он похож на обычную обертку над значением, с методами get(), set() 
и remove() для доступа к нему, и дополнительным фабричным методом 
ThreadLocal.withInitial(), устанавливающим значение по-умолчанию.

Отличие тред-локальной переменной от обычной в том, что ThreadLocal хранит 
отдельную независимую копию значения для каждого ее использующего потока. 
Работа с такой переменной потокобезопасна.

Проще говоря, объект класса ThreadLocal хранит внутри не одно значение, а как бы 
хэш-таблицу поток➝значение, и при использовании обращается к значению 
для текущего потока.

Первый, самый очевидный вариант использования – данные, относящиеся 
непосредственно к треду, определенный пользователем «контекст потока». 
На скриншоте ниже пример такого использования: ThreadId.get() вернет 
порядковый номер текущего треда.

Другой случай, с которым локальная переменная потока может помочь – кэширование 
read-only данных в многопоточной среде без дорогостоящей синхронизации.

Помимо обычного ThreadLocal, в стандартной библиотеке присутствует его расширение
InheritableThreadLocal. Этот класс «наследует» значение – изначально берет его 
для потока, являющегося родителем текущего.

Что такое FutureTask?
==============
FutureTask представляет собой отменяемое асинхронное вычисление в параллельном 
Java приложении. Этот класс предоставляет базовую реализацию Future, с методами 
для запуска и остановки вычисления, методами для запроса состояния вычисления 
и извлечения результатов. Результат может быть получен только когда вычисление 
завершено, метод получения будет заблокирован, если вычисление ещё не завершено. 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable.
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

Что такое Thread Pool?
=================
Создание потока является затратной по времени и ресурсам операцией. Количество 
потоков, которое может быть запущено в рамках одного процесса также ограниченно. 
Чтобы избежать этих проблем и в целом управлять множеством потоков более 
эффективно в Java был реализован механизм пула потоков (thread pool), который 
создаётся во время запуска приложения и в дальнейшем потоки для обработки 
запросов берутся и переиспользуются уже из него. Таким образом, появляется 
возможность не терять потоки, сбалансировать приложение по количеству потоков 
и частоте их создания.

Что такое Semaphore?
===============
Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон
синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение
счётчика задаётся в конструкторе при создании синхронизатора, когда поток заходит
в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток
его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий
поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore
используется для защиты дорогих ресурсов, которые доступны в ограниченном
количестве, например подключение к базе данных в пуле.

Чем отличается submit от execute у ExecutorServices?
======================
Оба метода являются способами подачи задачи в пул потоков, но между ними есть
небольшая разница.

execute(Runnable command) определён в интерфейсе Executor и выполняет поданную
задачу и ничего не возвращает.

submit() – перегруженный метод, определённый в интерфейсе ExecutorService. 
Способен принимать задачи типов Runnable и Callable и возвращать объект Future, 
который можно использовать для контроля и управления процессом выполнения, 
получения его результата.

Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
==============================
shutdown() просто сообщит службе-исполнителю, что он не может принимать новые 
задачи, но уже отправленные задачи продолжают выполняться
shutdownNow() будет делать то же самое И будет попытаться отменить уже 
отправленные задачи, прервав соответствующие потоки. Обратите внимание, 
что если ваши задачи игнорируют прерывание, shutdownNow будет вести себя 
точно так же, как shutdown.

Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
==================
Например, если надо создать пул с 2мя потоками, то делается это так:
ExecutorService service = Executors.newFixedThreadPool(2);
Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:
ExecutorService service = Executors.newCachedThreadPool();

Что такое ReadWriteLock?
=======================
ReadWriteLock – это интерфейс расширяющий базовый интерфейс Lock. Используется для
улучшения производительности в многопоточном процессе и оперирует парой связанных
блокировок (одна - для операций чтения, другая - для записи). Блокировка чтения
может удерживаться одновременно несколькими читающими потоками, до тех пор пока
не появится записывающий. Блокировка записи является эксклюзивной.

В чём отличие Thread от FutureTask? 
======================
1. Thread работает с объектом Runnable, FutureTask - Runnable или Callable.
2. Thread не выдает результата и не бросает проверяемое исключение,
FutureTask - выдает результат или проверяемое исключение task.get().
3. Thread запускается - в отдельном потоке thread.start(), без отдельного потока
thread.run().
FutureTask запускается - в отдельном потоке executor.execute(task), new Thread(task).start(),
без отдельного потока task.run()
4. Thread - это поток, исполняющий Runnable. FutureTask - это продвинутая реализация
Runnable, добавляющая туда преимущества Future.

В чём отличие Thread.interrupt() и FutureTask.cancel().
=============================
1) thread.interrupt() - посылает потоку сигнал о прерывании
2) task.cancel(true/false) имеет два варианта, если задание уже исполняется: 
прерывать поток (true) или уже не мешать (false)

Расскажите про шаблон проектирования Producer Consumer.
====================
Шаблон заключается в разделении потоков по виду их деятельность на поставщиков 
и потребителей. Поставщики и потребители не общаются друг с другом напрямую, 
вместо этого передавая работу через общую очередь. Такой подход позволяет 
независимо разрабатывать поставщиков и потребителей, так как они не знают друг 
о друге, но знают только формат общения. Другое преимущество - возможность 
поставщиков и потребителей работать на разной скорости: медленный потребитель 
не будет тормозить быстрого поставщика.