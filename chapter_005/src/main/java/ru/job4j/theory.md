Garbage Collection Theory
=================================
В JVM память делится на два сегмента – Heap и Permanent Generation.
---------------------------------
**Permanent generation используется только JVM для хранения необходимых данных, в том числе метаданные о созданных объектах.** При каждом создании объекта JVM будет «класть» некоторый набор данных в PG.

Размер PG можно задать двумя параметрами JVM: **-XX:PermSize** – задаёт минимальный, или изначальный, размер PG, и **-XX:MaxPermSize** – задаёт максимальный размер.

**Heap – основной сегмент памяти, где хранятся все ваши объекты. Heap делится на два подсегмента, Old Generation и New Generation. New Generation в свою очередь делится на Eden и два сегмента Survivor.**

JVM память = Permanent Generation и Heap(Old Generation, New Generation(Eden, Survivor))
---------------------------------
Размер heap также можно указать параметрами -Xms (минимум) и -Xmx (максимум).

Новые объекты создаются в Eden. Когда вы хотите создать новый объект, но места в Eden уже нет, JVM проводит garbage collection, что значит, что JVM ищет в памяти все объекты, которые более не нужны, и избавляется от них, то есть JVM обнаруживает, что Eden полон и надо провести чистку. 

Copy Collection
---------------------------------
Самый простой алгоритм для garbage collection называется **Copy Collection**. На первом этапе (**Mark**) помечаются неиспользуемые объекты. На втором (**Copy**) объекты, которые ещё нужны копируется в сегмент survivor. Сегментов Survivor два, и они меньше Eden. Теперь все объекты, которые мы хотим, чтобы они были сохранены, скопированы в Survivor, и JVM просто удаляет всё из Eden. Этот алгоритм создаёт кое-что, что называется моментом, «когда мир остановился». Во время выполнения GC все другие процессы в JVM переводятся в состояние паузы, ради того, чтобы никакой из них не попробовал влезть в память после того, как мы скопировали всё оттуда, что привело бы к потере того, что сделано. Copy Collection работает хорошо в том случае, если у нас небольшое приложение, много мусора и мало полезных объектов.

Mark-Sweep-Compact Collection
---------------------------------
1) «Mark»: помечаются неиспользуемые объекты.
2) «Sweep»: эти объекты удаляются из памяти.
3) «Compact»: объекты размещаются, занимая свободные слоты, что освобождает пространство на тот случай, если потребуется создать «большой» объект.

Типы GC
==================

Слабая гипотеза о поколениях - чем дольше прожил объект, тем выше вероятность того, что он будет жить и дальше.
Вот тут и возникает идея разделения объектов на младшее поколение (young generation) и старшее поколение (old generation). В соответствии с этим разделением и процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только младшее поколение, и полную сборку (full GC), которая может затрагивать оба поколения. Малые сборки выполняются достаточно часто и удаляют основную часть мертвых объектов. Полные сборки выполняются тогда, когда текущий объем выделенной программе памяти близок к исчерпанию и малой сборкой уже не обойтись.

При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение. В старшем поколении объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора.

Традиционно, при определении эффективности работы сборщика мусора учитываются следующие факторы:

Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются stop-the-world (или STW).
Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.
Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

G1
----
В G1 изменен подход к организации кучи. Память разбивается на множество регионов одинакового размера. Разделение регионов на Young Generation и Old Generation в данном случае логическое. 

Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

А с полной сборкой (точнее, здесь она называется смешанной (mixed)) все немного хитроумнее, чем в рассмотренных ранее сборщиках. В G1 существует процесс, называемый циклом пометки (marking cycle), который работает параллельно с основным приложением и составляет список живых объектов. За исключением последнего пункта, этот процесс выглядит уже знакомо для нас:

Initial mark. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.
Concurrent marking. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения.
Remark. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).
Cleanup. Очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно использовать для размещения новых объектов. Первая часть этого шага выполняется при остановленном основном приложении.

Следует иметь в виду, что для получения списка живых объектов G1 использует алгоритм Snapshot-At-The-Beginning (SATB), то есть в список живых попадают все объекты, которые были таковыми на момент начала работы алгоритма, плюс все объекты, созданные за время его выполнения. Это, в частности, означает, что G1 допускает наличие плавающего мусора, с которым мы познакомились при рассмотрении сборщика CMS.

После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

Очередной цикл пометки и, как следствие, очередные смешанные сборки будут запущены тогда, когда заполненность кучи превысит определенный порог.

Ситуации STW

Процессы переноса объектов между поколениями. Для минимизации таких пауз G1 использует несколько потоков.
Короткая фаза начальной пометки корней в рамках цикла пометки.
Более длинная пауза в конце фазы remark и в начале фазы cleanup цикла пометки.

Достоинства и недостатки

В целом считается, что сборщик G1 более аккуратно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. При этом он лишен и некоторых других недостатков CMS, например, он не фрагментирует память.

Расплатой за достоинства G1 являются ресурсы процессора, которые он использует для выполнения достаточно большой части своей работы параллельно с основной программой. В результате страдает пропускная способность приложения. Целевым значением пропускной способности по умолчанию для G1 является 90%. Для Parallel GC, например, это значение равно 99%. Это, конечно, не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует всегда иметь в виду.

Профилирование
================
Профилирование - это исследование поведения программы, используя информацию собранную во время выполнения программы. Цель анализа в том, чтобы определить, какие части программы можно оптимизировать, чтобы увеличить скорость выполнения и уменьшить потребляемую память.
