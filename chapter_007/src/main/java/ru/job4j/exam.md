Вопросы
=======
1. [Чем отличается процесс от потока?]:(Чем-отличается-процесс-от-потока?)
2. Каким образом можно создать поток?
3. Как работают методы sleep, yield, wait, notify и notifyAll?
4. Объясните следующие термины: монитор, мьютекс, критическая секция.
5. Как работает join()?
6. Что такое DeadLock? Приведите примеры.
7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
8. Различия в интерфейсах Runnable и Callable.
9. Различя между isInterrupted(), interrupted().
10. Что происходит при вызове Thread.interrupt()?
11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.
12. Назовите отличия synchronize{} и ReentrantLock.
13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.
14. Отличие Thread.start() и Thread.run()?
15. Объясните ключевое слово volatile.
16. Расскажите про приоритеты потока.
17. Что такое потоки-демоны?
18. Назовите все возможные состояния потока.
19. Что такое race condition?
20. Что такое Thread Local переменная? 
21. Что такое FutureTask?
22. Что такое Thread Pool?
23. Что такое Semaphore?
24. Чем отличается submit от execute у ExecutorServices?
25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
28. Что такое ReadWriteLock?
29. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().
30. Расскажите про шаблон проектирования Producer Consumer.

Чем отличается процесс от потока?
==========
Процесс - это выполняющаяся программа, состоит хотя бы из одного потока,
использует отдельное адресное пространство.
Поток - это часть программы, которая задает отдельный путь исполнения процесса.
Потоки используют одно адресное пространств процесса, взаимодействуют.

Каким образом можно создать поток?
=======================
Создать поток можно с помощью интерфейса Runnable, нужно переопределить 
метод run(), и передать его в новый поток.

    Runnable task = () -> {
		System.out.println("Hello, World!");
	};
	Thread thread = new Thread(task);
	thread.start();
	
Или можно создать потомка класса Thread и переопределить его метод run();

    public static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello, World!");
        }
    }

Как работают методы sleep, yield, wait, notify и notifyAll?
==========

Sleep
----
Статический метод.
Приостанавливает выполнение потока, в котором он был вызван, т.е. переключается
из RUNNABLE в TIMED_WAITING.

Yield
-----
Статический метод.
Заставляет процессор переключиться на обработку других потоков системы

Wait
-----
Нестатический метод.
Освобождает монитор и переводит вызывающий поток в состояние ожидания 
до тех пор, пока другой поток не вызовет метод notify().

Notify
----
Нестатический метод.
Продолжает работу потока, у которого ранее был вызван метод wait(

NotifyAll
----
Нестатический метод.
Возобновляет работу всех потоков, у которых ранее был вызван метод wait()


Объясните следующие термины: монитор, мьютекс, критическая секция.
======
Монитор
------
Монитор - это механизм для управления одновременным доступом к объекту.
Монитор — это дополнительная «надстройка» над мьютексом. С каждым объектом 
ассоциирован некоторый монитор, а потоки могут его занять или освободить.

Мьютекс
-------
1) Мьютекс - это объект, позволяющий "захватывать" себя одному и только одному потоку.
2) Если один поток "захватил" мьютекс, остальные потоки должны ждать, когда мьютекс освободиться.
3) Освободить мьютекс может только захвативший его поток.

Критическая секция
-----------
Это участок кода, в котором производится доступ к общему ресурсу, который 
не должен быть одновременно использован более чем одним потоком.

Как работает join()?
=======
Нестатический метод.
Это механизм, позволяющий одному потоку ждать завершения выполнения другого.
Например, чтобы главный поток подождал завершения побочного потока, 
необходимо выполнить join() в главном потоке.

Что такое DeadLock? Приведите примеры.
========
Deadlock или дедлок или взаимная блокировка — это ошибка, которая возникает, 
когда один поток держит мютекс, нужный второму потоку, 
а второй поток держит мютекс, нужный первому потоку.

Необходимо произвести две транзакции: со счета A на счет B перевести x денег, 
а со счета B на счет A – y. При неудачном стечении обстоятельств, транзакция 1 
займет монитор счета A, транзакция 2 займет монитор счета B. Результат – взаимная 
блокировка: транзакция 1 ждет, пока транзакция 2 освободит монитор счета B, но для 
этого транзакция 2 должна получить доступ к монитору A, занятому транзакцией 1.

Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
=========================
1. SynchronizedMap - при использовании потоком блокируется вся карта.
ConcurrentHashMap - блокируется только один bucket(ведро).
2. SynchronizedMap - использовать объект в момент времени может только один поток.
ConcurrentHashMap - читать могут все потоки, писать - один поток на bucket.
3. SynchronizedMap - кидает CocurrentModificationException если карта была изменена во время 
итерирования.
ConcurrentHashMap - не кидает CocurrentModificationException если карту изменили во время 
итерирования.
Но и ничего не гарантирует.

Различия в интерфейсах Runnable и Callable.
==================
1. Runnable - метод run(), ничего не возвращает.
Callable - метод call(), возвращает значение.
2. Runnable - запуск через Thread(Runnable).start(), ExecutorService, FutureTask.
Callable - запуск через ExecutorService, FutureTask.
3. Runnable - не бросает исключения, Callable - бросает проверяемые Exception. 

Callable - Возвращаемое значение и брошенные исключения из Callable записываются 
в объект класса Future.
Метод future.get() выдает возвращенное значение, если операция прошла успешно.

Различия между isInterrupted(), interrupted().
============================
1. thread.isInterrupted() - Нестатический метод. Возвращает информацию о любом потоке, 
на объекте которого вызван. 
boolean thread.isInterrupted(), boolean Thread.currentThread.isInterrupted()
Thread.interrupted() - Статический метод. Возвращает информацию только о потоке, в котором вызван.
Вызвать boolean Thread.interrupted().
2. isInterrupted - простой информационный метод.
interrupted - ставит у текущего потока флаг interrupted == false, т.е. сбрасывает статус прерывания.
 То есть после вызова Thread.interrupted() поток уже не считается прерванным.


Что происходит при вызове Thread.interrupt()?
===============
2) Если поток вызывает метод НЕ сам на себя, то сначала включается метод checkAccess и проверяет, 
что потоку разрешено изменять другой поток.
3) Затем, если поток заблокирован методами вроде wait(), join(), sleep, 
то бросается InterruptedException и ставится флаг interrupted==false.
4) Если же исключение не бросается, то потоку ставится флаг interrupted = true.

Перечислите ВСЕ причины по которым может выскочить InterruptedException.
==========================
1) Поток thread находится в состоянии WAITING или TIMED_WAITING 
и на него из другого потока применили метод thread.interrupt()
2) Просто написано: throw new InterruptedException()

Назовите отличия synchronize{} и ReentrantLock.
=================
В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного
и тонкого контроля блокировки ресурсов. ReentrantLock – распространённая 
реализация Lock, которая предоставляет Lock с таким же базовым поведением и 
семантикой, как у synchronized, но расширенными возможностями, такими как 
опрос о блокировании (lock polling), ожидание блокирования заданной 
длительности и прерываемое ожидание блокировки. Кроме того, он предлагает 
гораздо более высокую эффективность функционирования в условиях жесткой 
состязательности.

Приведите наиболее существенное отличие между CountDownLatch и Barrier.
===================
CyclicBarrier похож на CountDownLatch, но главное различие между ними в том, 
что использовать «замок» можно лишь единожды - после того, как его счётчик 
достигнет нуля, а «барьер» можно использовать неоднократно, даже после того, 
как он «сломается».


Отличие Thread.start() и Thread.run()
==============
Разница заключается в том, что Thread.start() запускает поток, который 
вызывает метод run() , в то время как Runnable.run() просто вызывает 
метод run() в текущем потоке.

Объясните ключевое слово volatile.
============= 
Если мы объявляем переменную с ключевым словом volatile, это значит, что она
всегда будет атомарно читаться и записываться и JVM не будет помещать ее в кэш.

Расскажите про приоритеты потока.
===================
Приоритеты потоков используются планировщиком потоков для принятия решений 
о том, когда какому из потоков будет разрешено работать. 
Теоретически высокоприоритетные потоки получают больше времени процессора, 
чем низкоприоритетные. Практически объем времени процессора, который получает 
поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса Thread: 
final void setPriority(int level). Значение level изменяется в пределах 
от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - 
Thread.NORM_PRlORITY = 5.

Получить текущее значение приоритета потока можно вызвав метод: 
final int getPriority() у экземпляра класса Thread.

Что такое потоки-демоны?
=========
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются 
неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне 
работы основных потоков выполнения и его деятельность заключается в обслуживании 
основных потоков приложения, то такой процесс может быть запущен как поток-демон 
с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. 
Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном 
или нет. Базовое свойство потоков-демонов заключается в возможности основного 
потока приложения завершить выполнение потока-демона (в отличие от обычных потоков)
с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще 
работает.

Назовите все возможные состояния потока.
=========
1) NEW - создан, не стартовал.
2) RUNNABLE - работает или ждет в очереди на процессорное время.
3) BLOCKED - ждет мьютекс (synchronized{} или lock.lock()). Дождавшись, перейдет в RUNNABLE.
4) WAITING - при вызове thread.join(), object.wait(), condition.await(), 
когда ждет notify(All)/signal(All).
5) TIMED_WAITING - как WAITING, но также пробуждается, если прошло заданное время. 
Методы Thread.sleep, object.wait(time), thread.join(time), lock.tryLock(time), condition.await(time).
6) TERMINATED - когда закончился метод run() или случилось RuntimeException и вышло 
за пределы метода run().

Что такое race condition?
===========
Состояние гонки (race condition) - ошибка проектирования многопоточной системы или
приложения, при которой эта работа напрямую зависит от того, в каком порядке 
выполняются потоки. Состояние гонки возникает когда поток, который должен 
исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение 
кода изменяется, из-за чего возникают недетерменированные ошибки.

Что такое Thread Local переменная?
=================
1) Объект класса ThreadLocal<E> создает для каждого потока свою переменную и свой объект, 
с которым работает только этот поток.
2) Например, сделаем поле ThreadLocal<String> name. В одном потоке зададим name.set("первый"), 
во втором - name.set("второй"). Будут созданы два разных объекта.
3) После этого первый поток, вызвав name.get(), получит "первый". Второй поток, вызвав name.get(),
 получит "второй".
4) Как только поток заканчивает работу, ссылки на созданные объекты делаются null,
и объекты собираются сборщиком мусора.

Что такое FutureTask?
==============
FutureTask представляет собой отменяемое асинхронное вычисление в параллельном 
Java приложении. Этот класс предоставляет базовую реализацию Future, с методами 
для запуска и остановки вычисления, методами для запроса состояния вычисления 
и извлечения результатов. Результат может быть получен только когда вычисление 
завершено, метод получения будет заблокирован, если вычисление ещё не завершено. 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable.
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

Что такое Thread Pool?
=================
1) Тред пул - это класс, который создает и держит в себе несколько потоков для выполнения задач.
2) В пул добавляются задачи (объекты Runnable, Callable, FutureTask) методом execute(task).
3) Когда поток из пула освобождается, он берет задачу и исполняет ее. Затем берет следующую 
и так далее.

Что такое Semaphore?
===============
1) Семафор - это объект, который может "захватываться" каким-то одним или несколькими потоками.
2) В семафоре определено некое число - количество потоков, которые могут одновременно пользоваться,
 "захватывать" этот семафор. Как правило это счетчик, который уменьшается на единицу с каждым 
 новым потоком. Если счетчик меньше или равен нулю - семафор освобождается и пускает к себе новый 
 "ожидающий захвата" поток.
3) Самый очевидный пример семафора - это менеджеры закачек - добавляем много файлов на закачку, 
но ограничиваем количество одновременно выполняемых закачек.

Чем отличается submit от execute у ExecutorServices?
======================
Оба метода являются способами подачи задачи в пул потоков, но между ними есть
небольшая разница.

execute(Runnable command) определён в интерфейсе Executor и выполняет поданную
задачу и ничего не возвращает.

submit() – перегруженный метод, определённый в интерфейсе ExecutorService. 
Способен принимать задачи типов Runnable и Callable и возвращать объект Future, 
который можно использовать для контроля и управления процессом выполнения, 
получения его результата.

Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
==============================
1) void shutdown(): пул перестает принимать новые задачи, но дорабатывает все уже стоящие в очереди.
2) List<Runnable> shutdownNow(): пул прерывает текущие задачи (thread.interrupt) 
и возвращает очередь ждавших исполнения задач.

Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
==================
Например, если надо создать пул с 2мя потоками, то делается это так:
ExecutorService service = Executors.newFixedThreadPool(2);
Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, 
но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), 
то это задается следующим образом:
ExecutorService service = Executors.newCachedThreadPool();

Что такое ReadWriteLock?
=======================
1) ReadWriteLock - объект, позволяющий многим потокам читать объект, но только одному - записывать.
2) Из объекта rwl класса ReadWriteLock получаются два замка: 
Lock rwl.readLock() и Lock rwl.writeLock().
3) Все, кто читает объект, вначале делают readLock.lock(). 
Так делать дозволено любому количеству потоков.
4) Если поток собирается изменить объект, он делает writeLock.lock(). 
Здесь он будет ждать, и получит блокировку только тогда, 
когда ни один поток не занимает readLock (т.е. не занимает объект).
5) С момента взятия потоком блокировки writeLock() и до ее снятия более ни один поток 
не пройдет через readLock или writeLock(). Объект будет заблокирован для всех, 
пока изменяющий поток не сделает writeLock.unlock().

В чём отличие Thread от FutureTask? 
======================
1. Thread работает с объектом Runnable, FutureTask - Runnable или Callable.
2. Thread не выдает результата и не бросает проверяемое исключение,
FutureTask - выдает результат или проверяемое исключение task.get().
3. Thread запускается - в отдельном потоке thread.start(), без отдельного потока
thread.run().
FutureTask запускается - в отдельном потоке executor.execute(task), new Thread(task).start(),
без отдельного потока task.run()
4. Thread - это поток, исполняющий Runnable. FutureTask - это продвинутая реализация
Runnable, добавляющая туда преимущества Future.

В чём отличие Thread.interrupt() и FutureTask.cancel().
=============================
1) thread.interrupt() - посылает потоку сигнал о прерывании
2) task.cancel(true/false) имеет два варианта, если задание уже исполняется: 
прерывать поток (true) или уже не мешать (false)

Расскажите про шаблон проектирования Producer Consumer.
====================
Шаблон заключается в разделении потоков по виду их деятельность на поставщиков 
и потребителей. Поставщики и потребители не общаются друг с другом напрямую, 
вместо этого передавая работу через общую очередь. Такой подход позволяет 
независимо разрабатывать поставщиков и потребителей, так как они не знают друг 
о друге, но знают только формат общения. Другое преимущество - возможность 
поставщиков и потребителей работать на разной скорости: медленный потребитель 
не будет тормозить быстрого поставщика.