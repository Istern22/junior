Чем отличается процесс от потока?
==========

Процесс - это выполняющаяся программа, состоит хотя бы из одного потока,
использует отдельное адресное пространство.
Поток - это часть программы, которая задает отдельный путь исполнения процесса.
Используют одно адресное пространств процесса, взаимодействуют.

Каким образом можно создать поток?
=======================
Создать поток можно с помощью интерфейса Runnable, нужно переопределить метод run(),
он будет выполняться в новом потоке.

    Runnable task = () -> {
		System.out.println("Hello, World!");
	};
	Thread thread = new Thread(task);
	thread.start();
	
Или можно создать потомка класса Thread и переопределить его метод run();

    public static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello, World!");
        }
    }

Как работают методы sleep, yield, wait, notify и notifyAll?
==========

Sleep
----
Приостанавливает выполнение потока, в котором он был вызван

Yield
-----
Заставляет процессор переключиться на обработку других потоков системы

Wait
-----
Освобождает монитор и переводит вызывающий поток в состояние ожидания 
до тех пор, пока другой поток не вызовет метод notify()

Notify
----
Продолжает работу потока, у которого ранее был вызван метод wait(

NotifyAll
----
Возобновляет работу всех потоков, у которых ранее был вызван метод wait()


Объясните следующие термины: монитор, мьютекс, критическая секция.
======
Монитор
------
Монитор - это механизм для управления одновременным доступом к объекту.
Монитор — это дополнительная «надстройка» над мьютексом. С каждым объектом 
ассоциирован некоторый монитор, а потоки могут его занять или освободить.

Мьютекс
-------
Мьютекс — это специальный объект для синхронизации потоков. Он есть у всех
объектов. Задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту
в определенное время был только у одного потока. Иными словами, только 
один поток в определенное время может работать с общими ресурсами. 
Попытки других потоков получить доступ к занятым ресурсам будут неудачными.
Возможны только два состояния — «свободен» и «занят», ими нельзя управлять вручную.

Критическая секция
-----------
Это участок кода, в котором производится доступ к общему ресурсу, который 
не должен быть одновременно использован более чем одним потоком.

Как работает join()?
=======
Это механизм, позволяющий одному потоку ждать завершения выполнения другого.
Например, чтобы главный поток подождал завершения побочного потока, необходимо выполнить
join() в главном потоке.

Что такое DeadLock? Приведите примеры.
========
Deadlock или дедлок или взаимная блокировка — это ошибка, которая происходит, 
когда нити имеют циклическую зависимость от пары синхронизированных объектов. 
Представьте, что одна нить входит в монитор объекта x, а другая — объекта y. 
Если нить в объекте x пытается вызвать любой синхронизированный метод объекта y, 
а объект y в то же самое время пытается вызвать любой синхронизированный метод 
объекта x, то нити застрянут в процессе ожидания. 

Необходимо произвести две транзакции: со счета A на счет B перевести x денег, 
а со счета B на счет A – y. При неудачном стечении обстоятельств, транзакция 1 
займет монитор счета A, транзакция 2 займет монитор счета B. Результат – взаимная 
блокировка: транзакция 1 ждет, пока транзакция 2 освободит монитор счета B, но для 
этого транзакция 2 должна получить доступ к монитору A, занятому транзакцией 1.

Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
=========================
Основное различие между этими двумя состояниями заключается в том, что 
ConcurrentHashMap блокирует только часть обновляемых данных, в то время как 
другая часть данных может быть доступна другим потокам. Однако 
Collections.synchronizedMap() будет блокировать все данные при обновлении, 
другие потоки могут получить доступ к данным только после освобождения 
блокировки.

Различия в интерфейсах Runnable и Callable.
==================
Интерфейс Runnable является функциональным интерфейсом и имеет единственный метод
run () , который не принимает никаких параметров и не возвращает никаких значений.
Интерфейс Callable - это универсальный интерфейс, содержащий единственный метод 
call (), который возвращает значение.

Оба интерфейса предназначены для представления задачи, которая может выполняться 
несколькими потоками. Задачи Runnable можно запускать с помощью класса Thread 
или ExecutorService , тогда как Callables можно запускать только с использованием 
ExecutorService.

Runnable - не бросает исключения, Callable - бросает. 

Различия между isInterrupted(), interrupted().
============================
Метод interrupted() - это метод класса, который всегда проверяет текущий поток 
и очищает флаг прерывания. Другими словами, второй вызов interrupted() вернет 
false.
Метод isInterrupted() - это метод экземпляра; он сообщает о статусе потока, 
на который он вызывается. Кроме того, он не очищает флаг прерывания. 
Если флаг установлен, он останется установленным после вызова этого метода.

Если вы используете interrupted , то вы просите "Have I been interrupted since the last time I asked?"

isInterrupted сообщает вам, прерван ли поток, который вы вызываете в данный момент.

Что происходит при вызове Thread.interrupt()?
===============


11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.
12. Назовите отличия synchronize{} и ReentrantLock.
13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.
14. Отличие Thread.start() и Thread.run()?
15. Объясните ключевое слово volatile.
16. Расскажите про приоритеты потока.
17. Что такое потоки-демоны?

Назовите все возможные состояния потока.
=========
Поток может выполняться. Он может быть готовым к выполнению, как только
получит время ЦП. Работающий поток может быть приостановлен, что приводит
к временному прекращению его активности. Выполнение приостановленного потока
может быть возобновлено, что позволяет продолжить его выполнение с того
места, где он был приостановлен. Поток может быть заблокирован на время ожидания
какого-нибудь ресурса. В любой момент поток может быть прерван, что
приводит к немедленной остановке его исполнения. Однажды прерванный поток
исполнения уже не может быть возобновлен.

19. Что такое race condition?
20. Что такое Thread Local переменная? 
21. Что такое FutureTask?
22. Что такое Thread Pool?
23. Что такое Semaphore?
24. Чем отличается submit от execute у ExecutorServices?
25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
28. Что такое ReadWriteLock?
29. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().
30. Расскажите про шаблон проектирования Producer Consumer.