1. Метасимволы для поиска совпадений границ строк или текста
Метасимвол	Назначение

^		начало строки
$		конец строки
\b		граница слова
\B		не граница слова
\A		начало ввода
\G		конец предыдущего совпадения
\Z		конец ввода
\z		конец ввода

2. Метасимволы для поиска символьных классов
Метасимвол	Назначение

\d		цифровой символ
\D		нецифровой символ
\s		символ пробела
\S		непробельный символ
\w		буквенно-цифровой символ или знак подчёркивания
\W		любой символ, кроме буквенного, цифрового или знака подчёркивания
.		любой символ

3. Метасимволы для поиска символов редактирования текста
Метасимвол	Назначение

\t		символ табуляции
\n		символ новой строки
\r		символ возврата каретки
\f		переход на новую страницу
\u 0085		символ следующей строки
\u 2028		символ разделения строк
\u 2029		символ разделения абзацев

4. Метасимволы для группировки символов
Метасимвол	Назначение

[абв]		любой из перечисленных (а,б, или в)
[^абв]		любой, кроме перечисленных (не а,б, в)
[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )
[a-d[m-p]]	объединение символов (от a до d и от m до p)
[a-z&&[def]]	пересечение символов (символы d,e,f)
[a-z&&[^bc]]	вычитание символов (символы a, d-z)

5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов.
Метасимвол	Назначение

?		один или отсутствует
*		ноль или более раз
+		один или более раз
{n}		n раз
{n,}		n раз и более
{n,m}		не менее n раз и не более m раз

Образец класса
java.lang. Объект
java.util.regex. Образец
Все Реализованные Интерфейсы:
Сериализуемый

public final class Pattern
extends Object
implements Serializable
Скомпилированное представление регулярного выражения.
Регулярное выражение, определенное как строка, должно сначала быть скомпилировано в экземпляр этого класса. 
Получающийся образец может тогда использоваться, чтобы создать a Matcher объект, который может соответствовать произвольный символьные последовательности 
против регулярного выражения. Все состояние, включенное в выполнение соответствия, находится в matcher, очень много matchers могут совместно использовать тот же самый образец.

Типичная последовательность вызова таким образом

 Pattern p = Pattern.compile("a*b");
 Matcher m = p.matcher("aaaaab");
 boolean b = m.matches();
A matches метод определяется этим классом как удобство для того, когда регулярное выражение используется только однажды. 
Этот метод компилирует выражение и соответствует входную последовательность против этого в единственном вызове. Оператор

 boolean b = Pattern.matches("a*b", "aaaaab");
эквивалентно этим трем операторам выше, хотя для повторных соответствий это менее эффективно, так как это не позволяет скомпилированному образцу быть снова использованным.
Экземпляры этого класса являются неизменными и являются безопасными для использования многократными параллельными потоками. 
Экземпляры Matcher класс не безопасен для такого использования.

Сводка конструкций регулярного выражения
*
Создать	Соответствия
 
Символы
x	Символ x
\\	Символ наклонной черты влево
\0 n	Символ с восьмеричным значением 0 n (0 <= n <= 7)
\0 nn	Символ с восьмеричным значением 0 nn (0 <= n <= 7)
\0 mnn	Символ с восьмеричным значением 0 mnn (0 <= м. <= 3, 0 <= n <= 7)
Гд \x	Символ с шестнадцатеричным значением гд 0x
\u hhhh	Символ с шестнадцатеричным значением 0x hhhh
\x {h... h}	Символ с шестнадцатеричным значением 0x h... h (Character.MIN_CODE_POINT  <= 0x h... h <= Character.MAX_CODE_POINT)
\t	Символ вкладки ('\u0009')
\n	Новая строка (перевод строки) символ ('\u000A')
\r	Символ возврата каретки ('\u000D')
\f	Символ перевода формата ('\u000C')
\a	Предупреждение (звонок) символ ('\u0007')
\e	Символ ESC ('\u001B')
\c x	Управляющий символ, соответствующий x
 
Классы символов
[abc]	a, b, или c (простой класс)
[^abc]	Любой символ кроме a, b, или c (отрицание)
[a-zA-Z]	a через z или A через Z, содержащий (диапазон)
[a-d[m-p]]	a через d, или m через p: [a-dm-p] (объединение)
[a-z&&[def]]	d, e, или f (пересечение)
[a-z&&[^bc]]	a через z, за исключением b и c: [ad-z] (вычитание)
[a-z&&[^m-p]]	a через z, и не m через p: [a-lq-z] (вычитание)
 
Предопределенные классы символов
.	Любой символ (может или, возможно, не соответствует разделители строки),
\d	Цифра: [0-9]
\D	Нецифра: [^0-9]
\s	Пробельный символ: [ \t\n\x0B\f\r]
\S	Непробельный символ: [^\s]
\w	Символ слова: [a-zA-Z_0-9]
\W	Символ неслова: [^\w]
 
Классы символов POSIX (US-ASCII только)
\p{Lower}	Строчный буквенный символ: [a-z]
\p{Upper}	Прописной алфавитный character:[A-Z]
\p{ASCII}	Весь ASCII:[\x00-\x7F]
\p{Alpha}	Алфавитный character:[\p{Lower}\p{Upper}]
\p{Digit}	Десятичная цифра: [0-9]
\p{Alnum}	Алфавитно-цифровой character:[\p{Alpha}\p{Digit}]
\p{Punct}	Пунктуация: Один из <=>!"#$%&'()*+,-./:;?@[\]^_`{|}~
\p{Graph}	Видимый символ: [\p{Alnum}\p{Punct}]
\p{Print}	Печатаемый символ: [\p{Graph}\x20]
\p{Blank}	Пространство или вкладка: [ \t]
\p{Cntrl}	Управляющий символ: [\x00-\x1F\x7F]
\p{XDigit}	Шестнадцатеричная цифра: [0-9a-fA-F]
\p{Space}	Пробельный символ: [ \t\n\x0B\f\r]
 
java.lang. Классы символов (простой символьный тип java)
\p{javaLowerCase}	Эквивалентный java.lang. Character.isLowerCase ()
\p{javaUpperCase}	Эквивалентный java.lang. Character.isUpperCase ()
\p{javaWhitespace}	Эквивалентный java.lang. Character.isWhitespace ()
\p{javaMirrored}	Эквивалентный java.lang. Character.isMirrored ()
 
Классы для сценариев Unicode, блоков, категорий и двоичных свойств
\p{IsLatin}	Латинский символ сценария (сценарий)
\p{InGreek}	Символ в греческом блоке (блок)
\p{Lu}	Прописная буква (категория)
\p{IsAlphabetic}	Буквенный символ (двоичное свойство)
\p{Sc}	Обозначение денежной единицы
\P{InGreek}	Любой символ кроме одного в греческом блоке (отрицание)
[\p{L}&&[^\p{Lu}]] 	Любая буква кроме прописной буквы (вычитание)
 
Граница matchers
^	Начало строки
$	Конец строки
\b	Граница слова
\B	Граница неслова
\A	Начало ввода
\G	Конец предыдущего соответствия
\Z	Конец ввода, но для заключительного разделителя, если любой
\z	Конец ввода
 
Жадные кванторы
X?	X, однажды или нисколько
X*	X, нуль или больше раз
X+	X, один или более раз
X{n}	X, точно n времена
X{n,}	X, по крайней мере n времена
X{n,m}	X, по крайней мере n, но не больше чем м. времен
 
Неохотные кванторы
X??	X, однажды или нисколько
X*?	X, нуль или больше раз
X+?	X, один или более раз
X{n}?	X, точно n времена
X{n,}?	X, по крайней мере n времена
X{n,m}?	X, по крайней мере n, но не больше чем м. времен
 
Притяжательные кванторы
X?+	X, однажды или нисколько
X*+	X, нуль или больше раз
X++	X, один или более раз
X{n}+	X, точно n времена
X{n,}+	X, по крайней мере n времена
X{n,m}+	X, по крайней мере n, но не больше чем м. времен
 
Логические операторы
XY	X сопровождаемый Y
X|Y	Или X или Y
( X)	X, как группа фиксации
 
Обратные ссылки
\ n	Независимо от того, что энная группа фиксации соответствовала
\ k <имени>	Независимо от того, что именованная группа фиксации "имя" соответствовала
 
Цитата
\	Ничто, но кавычки следующий символ
\Q	Ничто, но кавычки все символы до \E
\E	Ничто, но заключение в кавычки концов не запускалось \Q
 
Специальные конструкции (именованное получение и неполучающий)
(?<name> X)	X, как именованная группа фиксации
(?: X)	X, как негруппа фиксации
(?idmsuxU-idmsuxU) 	Ничто, но соответствие поворотов не отмечает я d м. s u x U на - прочь
(?idmsux-idmsux: X)  	X, как негруппа фиксации с данными флагами я d м. s u x на - прочь
(?= X)	X, через нулевую ширину положительное предвидение
(?! X)	X, через нулевую ширину отрицательное предвидение
(?<= X)	X, через нулевую ширину положительный lookbehind
(?<! X)	X, через нулевую ширину отрицательный lookbehind
(?> X)	X, как независимая, негруппа фиксации
Наклонные черты влево, Escape, и заключение в кавычки
Символ наклонной черты влево ('\') служит, чтобы представить оставленные конструкции, как определено в таблице выше, так же как к символам кавычек, 
которые иначе были бы интерпретированы как неоставленные конструкции. Таким образом выражение, которое \\ соответствует единственной наклонной черте влево и \{, 
соответствует левую фигурную скобку.

Это - ошибка использовать наклонную черту влево до любого буквенного символа, который не обозначает оставленную конструкцию; они резервируются для будущих расширений 
языка регулярных выражений. Наклонная черта влево может использоваться до небуквенного символа независимо от того, является ли тот символ частью неоставленной конструкции.

Наклонные черты влево в пределах строковых литералов в исходном коде Java интерпретируются как требуется Спецификацией языка Java™, 
поскольку любой Unicode выходит (разделите 3.3), или другие символьные Escape (разделяют 3.10.6) поэтому необходимо удвоить наклонные черты влево в строковых литералах, 
которые представляют регулярные выражения, чтобы защитить их от интерпретации компилятором Байт-кода Java. "\b" строкового литерала, например, соответствует единственный 
символ возврата когда интерпретирующийся как регулярное выражение, в то время как "\\b" соответствует границу слова. Строковый литерал "\(hello\)" недопустим и приводит 
к ошибке времени компиляции; чтобы соответствовать строке (hello) строковый литерал, "\\(hello\\)" должен использоваться.

Классы символов
Классы символов могут появиться в пределах других классов символов, и могут быть составлены (неявным) оператором объединения и перекрестным оператором (&&). 
Оператор объединения обозначает класс, который содержит каждый символ, который находится в по крайней мере одном из его классов операнда. Перекрестный оператор обозначает 
класс, который содержит каждый символ, который находится в обоих из его классов операнда.

Приоритет операторов класса символов следующим образом от самого высокого до самого низкого:

1    	Литеральный escape    	\x
2    	Группировка	[...]
3    	Диапазон	a-z
4    	Объединение	[a-e][i-u]
5    	Пересечение	[a-z&&[aeiou]]
Отметьте, что различный набор метасимволов в действительности в классе символов чем вне класса символов. Например, регулярное выражение, . 
теряет свое особое значение в классе символов, в то время как выражение - становится метасимволом формирования диапазона.

Разделители строки
Разделитель строки - один - или двухсимвольная последовательность, которая отмечает конец строки входной последовательности символа. 
Следующее распознается как разделители строки:

Новая строка (перевод строки) символ ('\n'),
Символ возврата каретки, сопровождаемый сразу символом новой строки ("\r\n"),
Автономный символ возврата каретки ('\r'),
Символ следующей строки ('\u0085'),
Символ разделителя строки ('\u2028'), или
Символ разделителя абзаца ('\u2029).
Если UNIX_LINES режим активируется, тогда единственные распознанные разделители строки являются символами новой строки.

Регулярное выражение . не соответствует символ кроме разделителя строки если DOTALL флаг определяется.

По умолчанию, регулярные выражения, ^ и $ игнорируют разделители строки и только соответствуют вначале и конец, соответственно, всей входной последовательности. 
Если MULTILINE режим активируется тогда соответствия ^ в начале ввода и после любого разделителя строки кроме в конце ввода. 
Когда в MULTILINE режим соответствия $ как раз перед разделителем строки или концом входной последовательности.

Группы и получение
Групповое число
Группы фиксации перечисляются, считая их вводные круглые скобки слева направо. В выражении ((A)(B(C))), например, есть четыре таких группы:

1    	((A)(B(C)))
2    	(A)
3    	(B(C))
4    	(C)
Групповой нуль всегда обозначает все выражение.

Группы фиксации столь называют, потому что во время соответствия каждая подпоследовательность входной последовательности, которая соответствует такую группу, сохраняется. 
Полученная подпоследовательность может использоваться позже в выражении, через обратную ссылку, и может также быть получена от matcher, как только работа соответствия полна.

Название группы
Группа фиксации может также быть присвоена "имя", named-capturing group, и затем сослана спиной позже "именем". Названия группы составляются из следующих символов. 
Первым символом должен быть letter.

Прописные буквы 'A' через 'Z' ('\u0041' через '\u005a'),
Строчные буквы 'a' через 'z' ('\u0061' через '\u007a'),
Цифры '0' через '9' ('\u0030' через '\u0039'),
named-capturing group все еще нумеруется как описано в Групповом числе.

Полученный ввод, связанный с группой, всегда является подпоследовательностью что группа, последний раз соответствующая. 
Если группа будет оценена во второй раз из-за квантификации тогда, то ее ранее полученное значение, если таковые вообще имеются, будет сохранено, 
если вторая оценка перестанет работать. Соответствуя строку "aba" против выражения (a(b)?)+, например, листовая группа два набора к "b". 
Весь полученный ввод отбрасывается в начале каждого соответствия.

Группы, начинающие с (?, являются или чистыми, негруппами фиксации, которые не получают текст и не рассчитывают к групповому общему количеству, или именованной группе фиксации.

Поддержка Unicode
Этот класс находится в соответствии с Уровнем 1 Технического стандарта Unicode #18: Регулярное выражение Unicode, плюс Канонические Эквиваленты RL2.1.

Escape-последовательности Unicode, такие как \u2014 в исходном коде Java обрабатываются как описано в разделе 3.3 из Спецификации языка Java™. 
Такие escape-последовательности также реализуются непосредственно синтаксическим анализатором регулярного выражения так, чтобы Escape Unicode могли 
использоваться в выражениях, которые читаются из файлов или из клавиатуры. Таким образом строки "\u2014" и "\\u2014", в то время как не равный, компилируют 
в тот же самый образец, который соответствует символ с шестнадцатеричным значением 0x2014.

Символ Unicode может также быть представлен в регулярном выражении при использовании его Шестнадцатеричной нотации (шестнадцатеричное значение кодовой точки) 
непосредственно как описано в конструкции \x{...}, например дополнительный символьный U+2011F может быть определен как \x{2011F} вместо двух последовательных 
escape-последовательностей Unicode суррогатной пары \uD840\uDD1F.

Сценарии Unicode, блоки, категории и двоичные свойства пишутся с \p и конструкциями \P как в Perl. \p{ prop} соответствует, если у ввода есть опора свойства, 
в то время как \P{ prop} не соответствует, если у ввода есть то свойство.

Сценарии, блоки, категории и двоичные свойства могут использоваться и внутри и снаружи класса символов.

Сценарии определяются любой с префиксом Is, как в IsHiragana, или при использовании script ключевое слово (или его краткая форма sc) как в script=Hiragana или sc=Hiragana.

Имена сценария, поддерживаемые Pattern допустимые имена сценария, принятые и определенные UnicodeScript.forName.

Блоки определяются с префиксом In, как в InMongolian, или при использовании ключевого слова block (или его краткая форма blk) как в block=Mongolian или blk=Mongolian.

Имена блока, поддерживаемые Pattern допустимые имена блока, принятые и определенные UnicodeBlock.forName.

Категории могут быть определены с дополнительным префиксом Is: Оба \p{L} и \p{IsL} обозначьте категорию букв Unicode. То же самое как сценарии и блоки, 
категории могут также быть определены при использовании ключевого слова general_category (или его краткая форма gc) как в general_category=Lu или gc=Lu.

Поддерживаемые категории являются таковыми Из Стандарта Unicode в версии, определенной Character класс. Названия категории - определенные в Стандарте, 
и нормативном и информативном.

Двоичные свойства определяются с префиксом Is, как в IsAlphabetic. Поддерживаемые двоичные свойства Pattern

Алфавитный
Идеограмма
Буква
Нижний регистр
Верхний регистр
Titlecase
Пунктуация
Управление
White_Space
Цифра
Hex_Digit
Noncharacter_Code_Point
Присвоенный
Предопределенные Классы символов и классы символов POSIX находятся в соответствии с рекомендацией Приложения C: Свойства Совместимости Регулярного выражения Unicode, 
когда UNICODE_CHARACTER_CLASS флаг определяется.

Классы	Соответствия
\p{Lower}	Нижний регистр character:\p{IsLowercase}
\p{Upper}	Верхний регистр character:\p{IsUppercase}
\p{ASCII}	Весь ASCII:[\x00-\x7F]
\p{Alpha}	Алфавитный character:\p{IsAlphabetic}
\p{Digit}	Десятичная цифра character:p{IsDigit}
\p{Alnum}	Алфавитно-цифровой character:[\p{IsAlphabetic}\p{IsDigit}]
\p{Punct}	Пунктуация character:p{IsPunctuation}
\p{Graph}	Видимый символ: [^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]
\p{Print}	Печатаемый символ: [\p{Graph}\p{Blank}&&[^\p{Cntrl}]]
\p{Blank}	Пространство или вкладка: [\p{IsWhite_Space}&&[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]
\p{Cntrl}	Управляющий символ: \p{gc=Cc}
\p{XDigit}	Шестнадцатеричная цифра: [\p{gc=Nd}\p{IsHex_Digit}]
\p{Space}	Пробел character:\p{IsWhite_Space}
\d	Цифра: \p{IsDigit}
\D	Нецифра: [^\d]
\s	Пробельный символ: \p{IsWhite_Space}
\S	Непробельный символ: [^\s]
\w	Символ слова: [\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}]
\W	Символ неслова: [^\w]
Категории, которые ведут себя как java.lang. Символьная булевская переменная ismethodname методы (за исключением осуждаемых) доступна через тот же самый \p{ prop} синтаксис, 
где у указанного свойства есть имя javamethodname.

Сравнение с Perl 5
Pattern механизм выполняет традиционное NFA-на-основе соответствие с упорядоченным чередованием, как это происходит в Perl 5.

Конструкции Perl, не поддерживаемые этим классом:

Предопределенные классы символов (символ Unicode)

    \h горизонтальный пробел

    \H не горизонтальный пробел

    \v вертикальный пробел

    \V не вертикальный пробел

    \R Любая последовательность разрыва строки Unicode \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]

    Unicode Соответствия \X расширенный кластер графемы

Конструкции обратной ссылки, \g{ n} для nthcapturing группы и \g{ name} для именованной группы фиксации.

Именованная символьная конструкция, \N{ name} для символа Unicode его именем.

Условное выражение создает (?( condition)X) и (?( condition)X|Y),

Встроенный код создает (?{ code}) и (??{ code}),

Встроенный синтаксис комментария (?#comment), и

Операции предварительной обработки \l \u, \L, и \U.

Конструкции, поддерживаемые этим классом, но не Perl:

Объединение класса символов и пересечение как описано выше.

Заметные различия от Perl:

В Perl \1 через \9 всегда интерпретируется как обратные ссылки; оставленное из наклонной черты влево число, больше чем 9, обрабатывается как обратная ссылка, 
если, по крайней мере, что много подвыражений существуют, иначе это интерпретируется, если возможный, как восьмеричный escape. В этом классе восьмеричные Escape 
должны всегда начинаться с нуля. В этом классе \1 через \9 всегда интерпретируется как обратные ссылки, и большее число принимается как обратная ссылка, если, 
по крайней мере, что много подвыражений существуют в той точке в регулярном выражении, иначе синтаксический анализатор отбросит цифры, пока число не будет меньшим 
или равно существующему числу групп, или это - одна цифра.

Perl использует флаг g, чтобы запросить соответствие, которое возобновляется где последнее брошенное соответствие. Эта функциональность обеспечивается неявно 
Matcher класс: Повторные вызовы find метод возобновит, где последнее брошенное соответствие, если matcher не сбрасывается.

В Perl встроенные флаги на верхнем уровне выражения влияют на целое выражение. В этом классе встроенные флаги всегда вступают в силу в точке, 
в которой они появляются, являются ли они на верхнем уровне или в пределах группы; в последнем случае флаги восстанавливаются в конце группы так же, как в Perl.

Для более точного описания поведения конструкций регулярного выражения, пожалуйста, см. Регулярные выражения Освоения, 3nd Выпуск, 
Джеффри Э. Ф. Friedl, О'Райли и Партнеры, 2006.

С тех пор:
1.4
См. Также:
String.split(String, int), String.split(String), Сериализированная Форма
Полевая Сводка
Поля 
Модификатор и Тип	Поле и Описание
static int	CANON_EQ
Включает канонической эквивалентности.
static int	CASE_INSENSITIVE
Включает нечувствительному к регистру соответствию.
static int	КОММЕНТАРИИ
Пробел разрешений и комментарии в образце.
static int	DOTALL
Включения dotall режим.
static int	ЛИТЕРАЛ
Парсинг литерала включений образца.
static int	МНОГОСТРОЧНЫЙ
Включает многострочному режиму.
static int	UNICODE_CASE
Включает осведомленному о Unicode сворачиванию случая.
static int	UNICODE_CHARACTER_CLASS
Включает версии Unicode Предопределенных классов символов и классов символов POSIX.
static int	UNIX_LINES
Режим строк Unix включений.
Сводка метода
Методы 
Модификатор и Тип	Метод и Описание
static Pattern	compile(String regex)
Компилирует данное регулярное выражение в образец.
static Pattern	compile(String regex, int flags)
Компилирует данное регулярное выражение в образец с данными флагами.
int	flags()
Возвраты флаги соответствия этого образца.
Matcher	matcher(CharSequence input)
Создает matcher, который будет соответствовать данный ввод против этого образца.
static boolean	matches(String regex, CharSequence input)
Компилирует данное регулярное выражение и попытки соответствовать данный ввод против этого.
Строка	pattern()
Возвращает регулярное выражение, от которого был скомпилирован этот образец.
static String	quote(String s)
Возвращает литеральный образец String для указанного String.
Строка[]	split(CharSequence input)
Разделяет данную входную последовательность вокруг соответствий этого образца.
Строка[]	split(CharSequence input, int limit)
Разделяет данную входную последовательность вокруг соответствий этого образца.
Строка	toString()
Возвращает строковое представление этого образца.
Методы java.lang унаследованный от класса. Объект
clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait
Полевая Деталь
UNIX_LINES
public static final int UNIX_LINES
Режим строк Unix включений.
В этом режиме только разделитель строки '\n' распознается в поведении ., ^, и $.

Режим строк Unix может также быть включен через встроенное выражение флага (?d).

См. Также:
Постоянные Значения полей
CASE_INSENSITIVE
public static final int CASE_INSENSITIVE
Включает нечувствительному к регистру соответствию.
По умолчанию нечувствительное к регистру соответствие предполагает, что только символы в наборе символов US-ASCII являются соответствующими. 
Осведомленное о Unicode нечувствительное к регистру соответствие может быть включено, определяя UNICODE_CASE флаг в соединении с этим флагом.

Нечувствительное к регистру соответствие может также быть включено через встроенное выражение флага (?i).

Определение этого флага может наложить небольшую потерю производительности.

См. Также:
Постоянные Значения полей
КОММЕНТАРИИ
public static final int COMMENTS
Пробел разрешений и комментарии в образце.
В этом режиме пробел игнорируется, и встроил комментарии, запускающиеся с #, игнорируются до конца строки.

Режим комментариев может также быть включен через встроенное выражение флага (?x).

См. Также:
Постоянные Значения полей
МНОГОСТРОЧНЫЙ
public static final int MULTILINE
Включает многострочному режиму.
В многострочном режиме выражения ^ и соответствие $ сразу после или как раз перед, соответственно, разделитель строки или конец входной последовательности. По умолчанию эти выражения только соответствуют вначале и конец всей входной последовательности.

Многострочный режим может также быть включен через встроенное выражение флага (?m).

См. Также:
Постоянные Значения полей
ЛИТЕРАЛ
public static final int LITERAL
Парсинг литерала включений образца.
Когда этот флаг определяется тогда строка ввода, которая определяет, что образец обрабатывается как последовательность литеральных символов. 
Метасимволам или escape-последовательностям во входной последовательности не дадут особого значения.

Флаги CASE_INSENSITIVE и UNICODE_CASE сохраняют свое воздействие на соответствие когда использующийся в соединении с этим флагом. Другие флаги становятся лишними.

Нет никакого встроенного символа флага для того, чтобы включить литеральному парсингу.

С тех пор:
1.5
См. Также:
Постоянные Значения полей
DOTALL
public static final int DOTALL
Включения dotall режим.
В dotall режиме выражение . соответствует любой символ, включая разделитель строки. По умолчанию это выражение не соответствует разделители строки.

Режим Dotall может также быть включен через встроенное выражение флага (?s). (s является мнемосхемой для "однострочного" режима, который является тем, что это вызывают в Perl.)

См. Также:
Постоянные Значения полей
UNICODE_CASE
public static final int UNICODE_CASE
Включает осведомленному о Unicode сворачиванию случая.
Когда этот флаг определяется тогда нечувствительное к регистру соответствие, когда включено CASE_INSENSITIVE отметьте, делается способом, непротиворечивым со Стандартом Unicode. По умолчанию нечувствительное к регистру соответствие предполагает, что только символы в наборе символов US-ASCII являются соответствующими.

Осведомленное о Unicode сворачивание случая может также быть включено через встроенное выражение флага (?u).

Определение этого флага может наложить потерю производительности.

См. Также:
Постоянные Значения полей
CANON_EQ
public static final int CANON_EQ
Включает канонической эквивалентности.
Когда этот флаг будет определен тогда, два символа, как будут полагать, будут соответствовать, если, и только если, их полные канонические разложения соответствуют. 
"a\u030A" выражения, например, будет соответствовать строке "\u00E5", когда этот флаг будет определен. 
По умолчанию соответствие не принимает каноническую эквивалентность во внимание.

Нет никакого встроенного символа флага для того, чтобы включить канонической эквивалентности.

Определение этого флага может наложить потерю производительности.

См. Также:
Постоянные Значения полей
UNICODE_CHARACTER_CLASS
public static final int UNICODE_CHARACTER_CLASS
Включает версии Unicode Предопределенных классов символов и классов символов POSIX.
Когда этот флаг определяется тогда (US-ASCII только), Предопределенные классы символов и классы символов POSIX находятся в соответствии 
с Техническим стандартом Unicode #18: Приложение C Регулярного выражения Unicode: Свойства Совместимости.

Режим UNICODE_CHARACTER_CLASS может также быть включен через встроенное выражение флага (?U).

Флаг подразумевает UNICODE_CASE, то есть, это включает осведомленному о Unicode сворачиванию случая.

Определение этого флага может наложить потерю производительности.

С тех пор:
1.7
См. Также:
Постоянные Значения полей
Деталь метода
скомпилировать
public static Pattern compile(String regex)
Компилирует данное регулярное выражение в образец.
Параметры:
regex - Выражение, которое будет скомпилировано
Броски:
PatternSyntaxException - Если синтаксис выражения недопустим
скомпилировать
public static Pattern compile(String regex,
              int flags)
Компилирует данное регулярное выражение в образец с данными флагами.
Параметры:
regex - Выражение, которое будет скомпилировано
flags - Флаги соответствия, немного маски, которая может включать CASE_INSENSITIVE, MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, 
LITERAL, UNICODE_CHARACTER_CLASS и COMMENTS
Броски:
IllegalArgumentException - Если битовые значения кроме тех, которые соответствуют определенным флагам соответствия, устанавливаются в flags
PatternSyntaxException - Если синтаксис выражения недопустим
образец
public String pattern()
Возвращает регулярное выражение, от которого был скомпилирован этот образец.
Возвраты:
Источник этого образца
toString
public String toString()
Возвращает строковое представление этого образца. Это - регулярное выражение, от которого был скомпилирован этот образец.

Переопределения:
toString в классе Object
Возвраты:
Строковое представление этого образца
С тех пор:
1.5
matcher
public Matcher matcher(CharSequence input)
Создает matcher, который будет соответствовать данный ввод против этого образца.
Параметры:
input - Символьная последовательность, которая будет соответствующей
Возвраты:
Новый matcher для этого образца
флаги
public int flags()
Возвраты флаги соответствия этого образца.
Возвраты:
Флаги соответствия, определенные, когда этот образец был скомпилирован
соответствия
public static boolean matches(String regex,
              CharSequence input)
Компилирует данное регулярное выражение и попытки соответствовать данный ввод против этого.
Вызов этого метода удобства формы

 Pattern.matches(regex, input);
ведет себя точно таким же образом как выражение
 Pattern.compile(regex).matcher(input).matches()
Если образец должен использоваться многократно, компилируя это, как только и снова используя это будет более эффективным чем вызов этого метода каждый раз.

Параметры:
regex - Выражение, которое будет скомпилировано
input - Символьная последовательность, которая будет соответствующей
Броски:
PatternSyntaxException - Если синтаксис выражения недопустим
разделение
public String[] split(CharSequence input,
             int limit)
Разделяет данную входную последовательность вокруг соответствий этого образца.
Массив, возвращенный этим методом, содержит каждую подстроку входной последовательности, которая завершается другой подпоследовательностью, 
которая соответствует этот образец или завершается к концу входной последовательности. Подстроки в массиве находятся в порядке, в котором они происходят во вводе. 
Если этот образец не соответствует подпоследовательности ввода тогда, у получающегося массива есть только один элемент, а именно, входная последовательность в строковой форме.

Параметр limit управляет числом раз, образец применяется и поэтому влияет на длину получающегося массива. 
Если предел n будет больше чем нуль тогда, то образец будет применен в большинстве n - 1 раз, длина массива будет не больше чем n, 
и последняя запись массива будет содержать весь ввод вне последнего соответствующего разделителя. 
Если n неположителен тогда, что образец будет применен настолько много раз насколько возможно, 
и у массива может быть любая длина. Если n будет нулем тогда, то образец будет применен настолько много раз насколько возможно, 
у массива может быть любая длина, и запаздывающие пустые строки будут отброшены.

Ввод "boo:and:foo", например, приводит к следующим результатам с этими параметрами:

Regex    

Предел    

Результат    

:	2	{ "boo", "and:foo" }
:	5	{ "boo", "and", "foo" }
:	-2	{ "boo", "and", "foo" }
o	5	{ "b", "", ":and:f", "", "" }
o	-2	{ "b", "", ":and:f", "", "" }
o	0	{ "b", "", ":and:f" }
Параметры:
input - Символьная последовательность, которая будет разделена
limit - Порог результата, как описано выше
Возвраты:
Массив строк, вычисленных, разделяя ввод вокруг соответствий этого образца
разделение
public String[] split(CharSequence input)
Разделяет данную входную последовательность вокруг соответствий этого образца.
Этот метод работает как будто, вызывая с двумя параметрами split метод с данной входной последовательностью и предельным параметром нуля. 
Запаздывающие пустые строки поэтому не включаются в получающийся массив.

Ввод "boo:and:foo", например, приводит к следующим результатам с этими выражениями:

Regex    

Результат

:	{ "boo", "and", "foo" }
o	{ "b", "", ":and:f" }
Параметры:
input - Символьная последовательность, которая будет разделена
Возвраты:
Массив строк, вычисленных, разделяя ввод вокруг соответствий этого образца
кавычка
public static String quote(String s)
Возвращает литеральный образец String для указанного String.
Этот метод производит a String это может использоваться, чтобы создать a Pattern это соответствовало бы строку s как будто это был литеральный образец.

Метасимволам или escape-последовательностям во входной последовательности не дадут особого значения.
Параметры:
s - Строка, чтобы быть literalized
Возвраты:
Замена литеральной строки
С тех пор:
1.5
